#![warn(clippy::all)]

pub struct FitResult {
    pub lower_deviation: f64,
    pub upper_deviation: f64,
    pub allowance: f64,
    pub fit_type: String,
}

pub const TOLERANCE_TABLE: &[(&str, f64, f64)] = &[("10H7", 0.0, 0.015), ("10g6", -0.015, -0.03)];

pub const IT_MAP: &[&str; 20] = &[
    "01", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15",
    "16", "17", "18",
];

// Stored as 1/10th of a micrometre
pub const IT_TABLE: &[[i32; 21]; 21] = &[
    [
        3, 3, 5, 8, 12, 20, 30, 40, 60, 100, 140, 250, 400, 600, 1_000, 1_400, 2_500, 4_000, 6_000,
        10_000, 14_000,
    ],
    [
        6, 4, 6, 10, 15, 25, 40, 50, 80, 120, 180, 300, 480, 750, 1_200, 1_800, 3_000, 4_800,
        7_500, 12_000, 18_000,
    ],
    [
        10, 4, 6, 10, 15, 25, 40, 60, 90, 150, 220, 360, 580, 900, 1_500, 2_200, 3_600, 5_800,
        9_000, 15_000, 22_000,
    ],
    [
        18, 5, 8, 12, 20, 30, 50, 80, 110, 180, 270, 430, 700, 1_100, 1_800, 2_700, 4_300, 7_000,
        11_000, 18_000, 27_000,
    ],
    [
        30, 6, 10, 15, 25, 40, 60, 90, 130, 210, 330, 520, 840, 1_300, 2_100, 3_300, 5_200, 8_400,
        13_000, 21_000, 33_000,
    ],
    [
        50, 6, 10, 15, 25, 40, 70, 110, 160, 250, 390, 620, 1_000, 1_600, 2_500, 3_900, 6_200,
        10_000, 16_000, 25_000, 39_000,
    ],
    [
        80, 8, 12, 20, 30, 50, 80, 130, 190, 300, 460, 740, 1_200, 1_900, 3_000, 4_600, 7_400,
        12_000, 19_000, 30_000, 46_000,
    ],
    [
        120, 10, 15, 25, 40, 60, 100, 150, 220, 350, 540, 870, 1_400, 2_200, 3_500, 5_400, 8_700,
        14_000, 22_000, 35_000, 54_000,
    ],
    [
        180, 12, 20, 35, 50, 80, 120, 180, 250, 400, 630, 1_000, 1_600, 2_500, 4_000, 6_300,
        10_000, 16_000, 25_000, 40_000, 63_000,
    ],
    [
        250, 20, 30, 45, 70, 100, 140, 200, 290, 460, 720, 1_150, 1_850, 2_900, 4_600, 7_200,
        11_500, 18_500, 29_000, 46_000, 72_000,
    ],
    [
        315, 25, 40, 60, 80, 120, 160, 230, 320, 520, 810, 1_300, 2_100, 3_200, 5_200, 8_100,
        13_000, 21_000, 32_000, 52_000, 81_000,
    ],
    [
        400, 30, 50, 70, 90, 130, 180, 250, 360, 570, 890, 1_400, 2_300, 3_600, 5_700, 8_900,
        14_000, 23_000, 36_000, 57_000, 89_000,
    ],
    [
        500, 40, 60, 80, 100, 150, 200, 270, 400, 630, 970, 1_550, 2_500, 4_000, 6_300, 9_700,
        15_500, 25_000, 40_000, 63_000, 97_000,
    ],
    [
        630, -1, -1, 90, 110, 160, 220, 320, 440, 700, 1_100, 1_750, 2_800, 4_400, 7_0000, 11_000,
        17_500, 28_000, 44_000, 70_000, 110_000,
    ],
    [
        800, -1, -1, 100, 130, 180, 250, 360, 500, 800, 1_250, 2_000, 3_200, 5_000, 8_000, 12_500,
        20_000, 32_000, 50_000, 80_000, 125_000,
    ],
    [
        1_000, -1, -1, 110, 150, 210, 280, 400, 560, 900, 1_400, 2_300, 3_600, 5_600, 9_000,
        14_000, 23_000, 36_000, 56_000, 90_000, 140_000,
    ],
    [
        1_250, -1, -1, 130, 180, 240, 330, 470, 660, 1_050, 1_650, 2_600, 4_200, 6_600, 10_500,
        16_500, 26_000, 42_000, 66_000, 105_000, 165_000,
    ],
    [
        1_600, -1, -1, 150, 210, 290, 390, 550, 780, 1_250, 1_950, 3_100, 5_000, 7_800, 12_500,
        19_500, 31_000, 50_000, 78_000, 125_000, 195_000,
    ],
    [
        2_000, -1, -1, 180, 250, 350, 460, 650, 920, 1_500, 2_300, 3_700, 6_000, 9_200, 15_000,
        23_000, 37_000, 60_000, 92_000, 150_000, 230_000,
    ],
    [
        2_500, -1, -1, 220, 300, 410, 550, 780, 1_100, 1_750, 2_800, 4_400, 7_000, 11_000, 17_500,
        28_000, 44_000, 70_000, 110_000, 175_000, 280_000,
    ],
    [
        3_150, -1, -1, 260, 360, 500, 680, 960, 1_350, 2_100, 3_300, 5_400, 8_600, 13_500, 21_000,
        33_000, 54_000, 86_000, 135_000, 210_000, 330_000,
    ],
];

pub fn get_tolerance(size: f64, deviation: &str, grade: &str) -> Option<(f64, f64)> {
    // For now we're ignoring the deviation...
    let size_rounded = size.round() as i32;
    let mut i = 21;
    let j = IT_MAP.iter().position(|&g| g == grade).unwrap() + 1;

    for (idx, row) in IT_TABLE.iter().enumerate() {
        if size_rounded < row[0] {
            i = idx - 1;
            break;
        }
    }

    if i < 22 && IT_TABLE[i][j] != -1 {
        Some((0.0, IT_TABLE[i][j] as f64 / 10000.0))
    } else {
        None
    }
    // TOLERANCE_TABLE.iter().find_map(|(name, lower, upper)| {
    //     if *name == tolerance_zone {
    //         Some((*lower, *upper))
    //     } else {
    //         None
    //     }
    // })
}

pub fn calculate_fit(
    hole_basic_size: f64,
    hole_deviation: &str,
    hole_grade: &str,
    shaft_basic_size: f64,
    shaft_deviation: &str,
    shaft_grade: &str,
) -> Option<FitResult> {
    let (hole_lower, hole_upper) = get_tolerance(hole_basic_size, hole_deviation, hole_grade)?;
    let (shaft_lower, shaft_upper) = get_tolerance(shaft_basic_size, shaft_deviation, shaft_grade)?;

    let lower_deviation = hole_lower; // shaft_lower - hole_upper;
    let upper_deviation = hole_upper; // shaft_upper - hole_lower;
    let allowance = shaft_upper - hole_upper;

    let fit_type = if lower_deviation > 0.0 {
        "Clearance".to_owned()
    } else if upper_deviation < 0.0 {
        "Interference".to_owned()
    } else {
        "Transition".to_owned()
    };

    Some(FitResult {
        lower_deviation,
        upper_deviation,
        allowance,
        fit_type,
    })
}
